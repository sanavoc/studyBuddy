
# StudyBuddy – Votre compagnon d’étude collaboratif

## Introduction

**StudyBuddy** est une application web innovante conçue pour faciliter l’étude et le travail en groupe. Que vous soyez étudiant ou professionnel, StudyBuddy vous permet de créer ou rejoindre des salles d’étude virtuelles pour rester motivé et concentré aux côtés d’autres utilisateurs. Chaque salle est dédiée à un sujet précis (matière scolaire, domaine professionnel, etc.) et peut être associée à un niveau d’étude (par exemple *Lycée*, *Université*, ou *Pro* pour professionnel). Le projet a été réalisé dans un but pédagogique afin de mettre en pratique des technologies web modernes côté front-end et back-end. L’objectif est de proposer une plateforme à la fois conviviale pour les utilisateurs et bien structurée pour les développeurs.

## Fonctionnalités

StudyBuddy offre de nombreuses fonctionnalités pour optimiser vos sessions de travail et encourager l’apprentissage collaboratif :

* **Salles d’étude publiques ou privées :** Les utilisateurs peuvent créer des **rooms** (salles virtuelles) sur un sujet donné, avec un niveau d’étude indicatif (ce champ est optionnel et peut être laissé vide ou défini à "pro" pour un contexte professionnel). Une salle peut être **publique** (visible et accessible par tous, figurant sur la page d’accueil) ou **privée** (accessible uniquement sur invitation). Chaque salle affiche le sujet, le niveau d’étude associé et le nombre de participants en temps réel, permettant aux autres de trouver facilement les groupes d’étude actifs les plus pertinents.

* **Invitation d’amis et gestion des amitiés :** StudyBuddy intègre un système social complet. Vous pouvez ajouter d’autres utilisateurs en ami, gérer vos demandes d’amis et consulter votre liste d’amis. Le créateur d’une salle privée peut inviter ses amis à le rejoindre pour une session d’étude en petit comité. Le système d’amis favorise la création de groupes de travail de confiance et facilite l’organisation de sessions privées.

* **Minuteur Pomodoro intégré :** Chaque salle offre un minuteur de type **Pomodoro** pour rythmer la session de travail. La technique Pomodoro consiste à alterner des périodes de travail concentré et de courtes pauses afin de maximiser l’attention et éviter la fatigue mentale. Concrètement, l’application permet de lancer un timer (inspiré du célèbre outil en ligne Pomofocus.io) configuré par défaut sur des intervalles classiques (par exemple 25 minutes de travail suivies de 5 minutes de pause), tout en restant **personnalisable**. Les utilisateurs peuvent ajuster la durée des sessions de travail ou de pause selon leur routine préférée. Ce minuteur collaboratif aide tous les membres de la room à synchroniser leurs efforts et **favorise une concentration soutenue** au sein du groupe.

* **Chat intégré dans chaque salle :** Pour chaque salle d’étude, un **chat** en temps réel est mis à disposition des participants. Cet espace de discussion permet d’échanger des questions, des conseils ou des messages d’encouragement pendant la session sans quitter l’interface d’étude. Les messages envoyés dans une salle ne sont visibles que par les membres de cette salle, ce qui garantit la pertinence des échanges. De plus, en complément du chat de groupe, StudyBuddy propose une **messagerie privée** (DM) pour discuter directement avec vos amis en dehors des salles, par exemple pour planifier une prochaine session ou s’entraider en tête-à-tête.

* **Personnalisation de l’apparence des salles :** Les utilisateurs peuvent personnaliser l’ambiance visuelle de leur salle d’étude. Par exemple, il est possible de choisir un thème de couleur, un arrière-plan (une image inspirante ou un environnement studieux) et d’autres préférences esthétiques. Cette personnalisation permet à chaque groupe de créer un espace de travail virtuel à son image, rendant l’expérience plus agréable et motivante. Un environnement visuel adapté peut contribuer à la concentration et au sentiment d’appropriation de la salle par le groupe.

* **Routines de travail personnalisées :** En plus du timer Pomodoro par défaut, StudyBuddy offre la possibilité de définir une **routine personnalisée** pour chaque session. Concrètement, le créateur ou les participants peuvent configurer la séquence de la session – par exemple, enchaîner trois cycles de 30 minutes de travail avec 10 minutes de pause, suivis d’une longue pause, ou encore alterner révision et quiz. Cette souplesse permet d’adapter la session au type de travail à accomplir (lecture, exercices, brainstorming, etc.) et aux préférences du groupe. Chaque utilisateur peut sauvegarder ses routines favorites afin de les réutiliser facilement.

* **Statistiques personnelles :** Pour encourager la motivation sur le long terme, chaque utilisateur dispose d’une page de **statistiques personnelles**. Celle-ci présente des données telles que le nombre de sessions effectuées, le temps total passé en étude concentrée, le nombre de cycles Pomodoro complétés, les salles les plus fréquentées ou encore des indicateurs de régularité. Les statistiques sont présentées de manière visuelle (graphiques, compteurs) pour suivre vos progrès et identifier vos habitudes de travail. Cette fonctionnalité s’inspire des principes de *quantified self* en permettant à chacun de mesurer ses efforts et de se fixer des objectifs (par exemple, étudier 10 heures par semaine). **StudyBuddy** transforme ainsi l’étude en un processus ludique où l’on peut voir ses progrès jour après jour.

* **Assistant IA dans les salles :** Une des caractéristiques innovantes de StudyBuddy est l’intégration d’un **assistant intelligent** au sein des salles d’étude. Cet assistant, basé sur une IA (intelligence artificielle), est disponible pour répondre aux questions des utilisateurs pendant leurs sessions. Concrètement, si vous butez sur un concept ou un exercice, il vous suffit d’interroger l’IA dans le chat de la salle. L’assistant IA peut fournir des explications, des pistes de solution ou des ressources supplémentaires sur le sujet de la salle, un peu comme un tuteur virtuel. Par ailleurs, l’IA peut prodiguer des conseils pour améliorer la concentration (par exemple des astuces pour éviter la procrastination) et même suggérer des pauses quand elle détecte une baisse d’attention. Cette fonctionnalité vise à enrichir l’expérience d’étude collaborative en apportant une aide contextuelle instantanée aux membres du groupe.

* **Page d’accueil communautaire :** La page d’accueil de StudyBuddy met en avant les salles publiques actives pour favoriser la découverte et la participation. Les salles publiques y sont listées et **triées par nombre de participants** (de la plus peuplée à la moins active), avec leur sujet et niveau d’étude affichés. Un utilisateur à la recherche d’un groupe d’étude peut ainsi, en un coup d’œil, identifier les salles les plus dynamiques correspondant à ses centres d’intérêt et y entrer pour se joindre à la session. Cette vitrine communautaire stimule l’aspect social de la plateforme en encourageant les utilisateurs à se rassembler autour de sujets communs. Un système de recherche ou de filtres (par sujet, niveau, langue, etc.) peut également être présent pour affiner la découverte de rooms. L’objectif est de créer une **communauté d’apprenants** active et solidaire, où chacun peut trouver son « buddy » d’étude idéal.

*(NB : Certaines de ces fonctionnalités, comme l’assistant IA, sont en cours d’implémentation dans le cadre du projet pédagogique et pourront évoluer. L’application est pensée pour être extensible afin d’y intégrer de nouvelles idées au fil du temps.)*

## Stack Technique (Architecture)

StudyBuddy s’appuie sur une **architecture web moderne** structurée en trois couches principales : un front-end riche, un back-end robuste et une base de données fiable. Le choix de ce stack technique vise à assurer une application réactive côté client, tout en garantissant la sécurité et la performance côté serveur.

* **Front-end (Angular) :** Le client web de StudyBuddy est développé avec le framework Angular. **Angular** est un framework front-end open source, spécialisé dans la création d’applications web monopage riches et dynamiques. Écrit en TypeScript et maintenu par Google, Angular permet de construire une application Single Page Application (SPA) modulable et maintenable. Concrètement, l’interface utilisateur de StudyBuddy est une application Angular qui tourne côté navigateur, offrant une expérience fluide sans rechargements constants de page. Angular est utilisé pour gérer les vues (composants UI), la navigation entre les écrans (par exemple, page d’accueil, vue d’une salle, profil utilisateur…), ainsi que les interactions en temps réel via le binding de données. Le choix d’Angular garantit une **bonne structuration du code front-end** et une séparation claire des composants, ce qui est précieux dans un contexte pédagogique pour illustrer les bonnes pratiques du développement côté client.

* **Back-end (Spring Boot) :** Le serveur de StudyBuddy est construit avec **Spring Boot**, un cadre applicatif Java très répandu pour créer des API web et des microservices. Spring Boot est un framework de développement Java open source particulièrement recommandé pour le développement d’API REST. Il simplifie grandement la configuration et la mise en route d’une application Spring en fournissant des paramétrages par défaut et une approche « convention over configuration ». Dans StudyBuddy, le back-end Spring Boot expose une **API RESTful** sécurisée qui gère la logique métier : création et gestion des salles, authentification des utilisateurs, envoi/réception des messages de chat, gestion des amis, enregistrement des sessions Pomodoro, etc. Chaque fonctionnalité évoquée côté client correspond à une ou plusieurs routes API côté serveur (par exemple, `POST /rooms` pour créer une salle, `GET /rooms` pour lister les salles publiques, `POST /rooms/{id}/messages` pour envoyer un message dans une salle, etc.). Le choix de Spring Boot dans ce projet pédagogique permet de montrer comment créer une API robuste en Java, de tirer parti de l’**écosystème Spring** (sécurité, JPA pour la base de données, websockets éventuellement pour le chat en temps réel, etc.) et d’illustrer la communication avec le front-end Angular.

* **Base de données (PostgreSQL) :** Les données persistantes de l’application (comptes utilisateurs, listes d’amis, salles, messages, statistiques…) sont stockées dans une base PostgreSQL. **PostgreSQL** est un système de gestion de base de données relationnelle open source réputé pour sa robustesse et sa conformité aux standards SQL. Il s’agit d’une base fiable et puissante, adaptée aussi bien à des projets de petite envergure qu’à des applications industrielles. Dans StudyBuddy, PostgreSQL stocke les tables principales décrivant l’application (voir section **Base de Données** ci-dessous). Le schéma relationnel est conçu pour assurer l’intégrité des données (utilisation de clés primaires/étrangères, contraintes, etc.) et des performances satisfaisantes (index sur les colonnes de jointure fréquentes, etc.). La base de données a été déployée via la plateforme *Railway* pour simplifier la mise en place dans le cloud – Railway est un service d’hébergement cloud qui permet de déployer facilement des bases de données PostgreSQL en ligne, ce qui a été utile dans le contexte pédagogique pour avoir un SGBD accessible à l’équipe de développement.

* **Communication et architecture globale :** L’application suit une architecture **client-serveur** classique. L’interface Angular interagit avec le serveur Spring Boot via des appels HTTP REST (probablement au format JSON pour l’envoi et la réception des données). Par exemple, lors de la connexion d’un utilisateur, Angular envoie les identifiants au back-end qui vérifie la validité via la base de données et renvoie un jeton d’authentification (si un système JWT ou session est mis en place). De même, lorsqu’un utilisateur envoie un message dans une salle, l’application front-end appelle l’API correspondante pour que le back-end enregistre le message en base puis le redistribue aux autres membres de la salle (soit via une route GET pollée régulièrement, soit via un mécanisme en temps réel comme WebSocket ou Server-Sent Events, selon l’implémentation choisie). Cette séparation nette des préoccupations (Angular pour la présentation, Spring Boot pour la logique serveur, PostgreSQL pour la persistance) rend le projet modulaire et évolutif. Elle permet également à différents développeurs de travailler en parallèle sur le front-end et le back-end en utilisant des technologies spécialisées pour chaque couche.

*(NB : Les sections d’installation, de déploiement et de configuration détaillée du projet sont omises ici. Dans un contexte réel, le README pourrait inclure les instructions pour cloner le dépôt, configurer les variables d’environnement (par ex. l’URL de la base de données PostgreSQL sur Railway), lancer le serveur Spring Boot et le front Angular, etc. Mais ces aspects seront documentés ultérieurement une fois le développement stabilisé.)*

## Base de Données – Schéma principal

La structure de la base de données relationnelle de StudyBuddy a été conçue pour représenter fidèlement les entités du domaine et leurs interactions. Voici un aperçu des **tables principales** (d’après le script SQL du projet) et de leur rôle :

* **Table `utilisateur`** – Contient les informations sur chaque utilisateur inscrit. On y trouve les champs classiques tels que un identifiant unique (`id`), le nom/pseudo, l’email, le mot de passe chiffré, etc., ainsi que d’autres attributs éventuels (date d’inscription, avatar, préférences utilisateur pour la personnalisation de l’interface, etc.). Chaque enregistrement correspond à un membre de la plateforme StudyBuddy. Cette table est centrale car la plupart des autres éléments du système y sont reliés via des clés étrangères.

* **Table `salle`** – Représente une **salle d’étude**. Les principaux champs incluent un `id` unique de salle, un titre ou nom de la salle, le sujet/thème de la session, le niveau d’étude associé (`niveau_etude` pouvant être null ou une valeur prédéfinie comme *Lycée*, *Prépa*, *Licence*, *Master*, *Pro*, etc.), un indicateur de visibilité **publique/privée** (par exemple un booléen `est_privee` ou un champ de type enum), ainsi que l’**identifiant du créateur** de la salle (clé étrangère vers `utilisateur`). On peut également stocker dans cette table des paramètres de personnalisation propres à la salle, tels que le thème visuel choisi, ou la routine Pomodoro par défaut si le créateur l’a définie pour la session. La table `salle` est reliée à `utilisateur` (chaque salle a un créateur, et potentiellement un administrateur/modérateur principal qui est le créateur). Elle se lie aussi à la table de participation (voir ci-dessous) et aux messages de chat.

* **Table `participant`** (ou `utilisateur_salle`) – Il s’agit d’une table de jointure **beaucoup-à-beaucoup** entre les utilisateurs et les salles. Chaque enregistrement indique qu’un certain utilisateur a rejoint une certaine salle. Les champs principaux sont une clé primaire composite ou un identifiant de participation, l’`id_utilisateur` et l’`id_salle` correspondants (tous deux clés étrangères vers les tables `utilisateur` et `salle`). Des champs supplémentaires peuvent préciser le rôle du participant (membre normal ou administrateur de la salle si on décide de gérer des co-animateurs) ou le statut de sa participation (par exemple, *en cours* si l’utilisateur est actuellement connecté à la salle, ou *terminé* s’il a quitté – ce genre d’information peut aussi être déduit en temps réel plutôt que stocké, selon l’implémentation). La table `participant` permet de savoir quels utilisateurs sont dans quelles salles, et d’afficher par exemple la liste des membres présents dans une room.

* **Table `message_salle`** – Correspond aux **messages de chat** postés dans les salles d’étude. Chaque message de salle comporte un `id` de message, l’identifiant de la salle concernée (`id_salle` clé étrangère vers `salle`), l’identifiant de l’auteur du message (`id_utilisateur` clé étrangère vers `utilisateur`), le contenu du message (texte), un timestamp (date/heure d’envoi) et éventuellement un type (par exemple pour distinguer un message texte normal d’une éventuelle notification système comme « X a rejoint la salle »). Cette table enregistre l’historique des conversations pour chaque salle. Lorsqu’un utilisateur ouvre une salle, l’application front-end peut charger les messages récents en interrogeant cette table via l’API. La conservation de ces messages permet aux participants qui rejoignent en cours de route de voir le contexte des discussions précédentes.

* **Table `relation_ami`** – Gère les **relations d’amitié** entre utilisateurs. Il s’agit typiquement d’une table contenant deux colonnes de clés étrangères (`id_utilisateur_1` et `id_utilisateur_2` référencant chacun un utilisateur) pour représenter une amitié (souvent on enregistre chaque paire d’amis une seule fois, en décidant que `id_utilisateur_1 < id_utilisateur_2` par exemple pour éviter les doublons inversés). Un champ de **statut** peut indiquer si l’amitié est *en attente* (demande envoyée non encore acceptée), *confirmée*, ou *bloquée* etc. Cette table permet de trouver la liste des amis d’un utilisateur (toutes les entrées où son id apparaît). Grâce à `relation_ami`, l’application peut, par exemple, afficher sur le profil de l’utilisateur ses amis, gérer l’acceptation/refus de demandes d’amitié, et limiter l’envoi de messages privés aux relations établies (selon les règles définies).

* **Table `message_prive`** – Semblable à `message_salle`, cette table stocke les **messages privés** échangés en **DM (direct message)** entre deux utilisateurs amis. Les champs comprennent un `id` de message privé, un champ `id_expediteur` (utilisateur qui envoie le message), un champ `id_destinataire` (utilisateur qui reçoit le message), le contenu du message, et la date/heure. Chaque entrée représente une ligne de conversation privée. Pour consulter les messages privés avec un ami, l’application effectuera une requête filtrant sur les deux identifiants utilisateur (peu importe l’ordre expéditeur/destinataire, on récupère tous les messages échangés entre A et B). Il est possible d’optimiser cette table ou de la fusionner conceptuellement avec `message_salle` en ajoutant un type de conversation (salle vs privé), mais dans un souci de simplicité pédagogique, elles peuvent être séparées.

* **Table `session_etude`** (ou `statistiques`) – Afin d’alimenter la page de statistiques personnelles, StudyBuddy peut enregistrer des données de session de chaque utilisateur. Par exemple, à chaque fois qu’un utilisateur démarre un timer Pomodoro dans une salle, on crée une entrée de session avec l’`id_utilisateur`, l’`id_salle`, un horodatage de début et de fin de session, ou à minima la durée totale concentrée réalisée. On peut stocker également le nombre de pomodoros enchaînés lors de cette session, le sujet étudié (hérité de la salle), etc. Cette table de **logs de sessions** permet ensuite de calculer les statistiques agrégées par utilisateur (total d’heures d’étude, régularité quotidienne, etc.). Alternativement ou en complément, certaines statistiques instantanées peuvent être calculées à la volée (par exemple nombre d’amis, nombre de salles créées, etc. depuis d’autres tables). Toutefois, pour tout ce qui est historique de temps de travail, la table `session_etude` est précieuse. Notons que cette partie du modèle de données peut être enrichie au fil du temps (par exemple en ajoutant une table `tache` si l’on introduit la gestion de to-do list associée aux sessions, etc., bien que cela dépasse le périmètre initial).

Ces tables principales sont reliées par des **clés étrangères** pour assurer l’intégrité référentielle. Par exemple : `participant.id_utilisateur` réfère à `utilisateur.id`, `participant.id_salle` réfère à `salle.id` ; de même `message_salle.id_salle` réfère à `salle.id` et `message_salle.id_utilisateur` réfère à l’auteur dans `utilisateur`. Les choix de types de données (entiers pour les identifiants, textes pour les contenus de messages, etc.) et de contraintes (unicité des emails utilisateurs, non-nullité des champs obligatoires, suppression en cascade des participations et messages d’une salle si celle-ci est supprimée, etc.) sont effectués dans le script SQL de création afin de préserver la cohérence des données.

L’illustration ci-dessous résume les relations entre entités : un utilisateur peut appartenir à plusieurs salles et une salle contient plusieurs participants ; les utilisateurs peuvent être amis entre eux ; ils échangent des messages soit dans les salles (chat de groupe) soit en privé en tête-à-tête. Ce schéma relationnel garantit que l’application peut facilement récupérer les informations nécessaires, par exemple : lister les membres d’une salle, afficher les messages d’une conversation, ou calculer le nombre de salles rejointes par un utilisateur.

*(NB : Le modèle de données pourra évoluer avec l’ajout de nouvelles fonctionnalités. Par exemple, l’intégration de l’IA pourrait nécessiter de stocker certaines interactions (questions posées à l’assistant) ou paramètres supplémentaires, mais dans un premier temps, beaucoup de ces traitements peuvent se faire sans stockage supplémentaire en base.)*

## Conclusion

En résumé, **StudyBuddy** se positionne comme une plateforme complète pour étudier de manière collaborative en combinant un ensemble d’outils motivants : rooms thématiques, pomodoro, chat, statistiques et intelligence artificielle. Du point de vue **utilisateur**, l’application est pensée pour être intuitive, interactive et utile au quotidien pour rester concentré et évoluer dans ses apprentissages. Du point de vue **développeur**, StudyBuddy est un projet structuré démontrant l’utilisation conjointe d’**Angular** et de **Spring Boot** avec une base **PostgreSQL**, illustrant les bonnes pratiques de conception d’une application web full-stack moderne. Ce projet à visée pédagogique a permis d’explorer tant la **conception fonctionnelle** (expérience utilisateur, gamification de l’étude, entraide communautaire) que la **réalisation technique** (architecture multicouche, API REST, persistance des données, etc.).

L’aventure StudyBuddy ne fait que commencer – de futures itérations pourraient approfondir l’aspect communautaire (système de badges, événements de groupe), enrichir l’IA (tuteur virtuel encore plus personnalisé) ou porter l’application sur mobile. Nous espérons que StudyBuddy donnera envie à chacun de **travailler ensemble efficacement** et constituera une base solide pour tous ceux qui souhaitent apprendre et collaborer grâce au numérique. Bonne étude à tous avec StudyBuddy !&#x20;
